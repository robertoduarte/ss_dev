******************************************************************************Event Control Functions************************************************************************************************************************************************************void slInitEvent(void)******************************************************************************Function:Initializes buffer for event and work control. 64 buffers are provided for events, and 256 buffers are provided for work.Note:The RAM areas for event and work are not initialized. Initialize the areas from the user program when they are accessed. ******************************************************************************EVENT *slGetEvent(void)******************************************************************************Function:Fetches the RAM area allocated for an event, and return its pointer.Note:The 128 byte area can be used freely by the user.64 areas are provided. When these areas are all used, a NULL code is returned.******************************************************************************EVENT *slSetEvent(void (*func)())******************************************************************************Function:Fetches an event and adds it to the end of the execution list. A specified function is then set as the execution function.Note:Although this is a 128 byte region, the first 16 bytes are used by the system. When there are no events left, a NULL code is returned.******************************************************************************EVENT *slSetEventNext(EVENT *evptr, void (*func)())******************************************************************************Function:Fetches an event and adds it to the execution list so that it is executed after a specified event. The function specified here is set as the execution function.Note:Although this is a 128 byte region, the first 16 bytes are used by the system. When there are no events left, a NULL code is returned.******************************************************************************void slReturnEvent(EVENT *evptr)******************************************************************************Function:Returns an event that is not registered in the execution list back to the system.Note:If this function is executed for an event that is registered in the execution list, execution is continued since it remains registered in the list.Although the returned pointer is set again in the system buffer, no check occurs to see if it has already been set. If the same pointer is returned multiple times, errors will occur when slGetEvent(), slSetEvent(), and slSetEventNext() are executed afterwards.******************************************************************************void slCloseEvent(EVENT *evptr)******************************************************************************Function:Takes out an event from the execution list and returns it back to the system. If work is set, it is also returned.Note:If an event that does not exist in the execution list is specified, this results in incorrect list information.  The list is therefore modified for a nonexistent event and data is written to an unpredictable address. This may cause the CPU to crash.Although the returned pointer is set again in the system buffer, no check occurs to see if it has already been set. If the same pointer is returned multiple times, errors will occur when slGetEvent(), slSetEvent(), and slSetEventNext() are executed afterwards.******************************************************************************void slExecuteEvent(void)******************************************************************************Function: Events set in the execution list are executed in sequence from the start of the list.Note: Execution occurs at each iteration of the main loop.******************************************************************************WORK *slGetWork(void)******************************************************************************Function:Reads out RAM areas allocated for work, and returns its pointer.Note:A work area is a 64 byte region with the first 4 bytes as list pointers used by the system. The remaining 60 bytes can be used freely by the user. If the pointer is set to the work area for the event structure, it is returned to the system when the event is closed.******************************************************************************void slReturnWork(WORK *wkptr)******************************************************************************Function: Returns RAM areas used for work back to the system.Note: Although the returned pointer is set again in the system buffer, no check occurs to see if it has already been set. If the same pointer is returned multiple times, errors will occur when slGetWork() is executed afterwards.******************************************************************************Setting and Executing Events******************************************************************************Since the execution list is cleared after slInitEvent() is executed, the user must set execution events to the list.Either slSetEvent() or slSetEventNext() is used to set events.void *eventtbl[] = {    init_camera,    init_player1,    init_player2,    init_enemyctrl};void InitGame(){    void  **evrdptr;    EVENT  *evptr;    int	cnt;    slInitEvent();   /* Initialize event control variables */    evrptr = eventtbl;    for(cnt = sizeof(eventtbl) / sizeof(void *); cnt-- > 0;){        evptr = slSetEvent(*evrptr++);    }    slInitPolygon(TV_320x224);}void Game(){    slExecuteEvent();   /* Event execution */    slSynch();          /* Output polygon data, video display sync */}Events are executed each time slExecuteEvent() is called.Each event is basically executed in the order in which it was set.The event set at the beginning is defined as the system variable EventTop. With this as a starting point, the event pointer is defined in sequence to the EventNow variable and calls the processing function for each event. Processing functions are defined in the following formats.void function(EVENT *evptr){      ...                  /* Event processing */}In assembly:_function:      ...                  ; Event processing                           ; The event pointer is set in the r4 register      rts      nopWhen one event ends, the next pointer in that event's structure is input as the EventNow variable. Execution moves to the processing function in the same manner. This is repeated until the next pointer reaches NULL.EventTop: --+            |            |    +------------------+            +--> | *work = NULL     |                 | *before = NULL   |            +--  | *next            |            |    | *exad()          |            |    |  user[]          |            |    +------------------+            |            |    +------------------+       +------------------+            +--> | *work            |  ---> | *next            | -+                 | *before          |       |                  |  |            +--  | *next            |       |                  |  |            |    | *exad()          |       +------------------+  |            |    |  user[]          |   +-------------------------+            |    +------------------+   |            |                           |   +------------------+            |    +------------------+   +-> | *next = NULL     |EventLast: -+--> | *work            |       |                  |                 | *before          |       |                  |                 | *next = NULL     |       +------------------+                 | *exad()          |                 |  user[]          |                 +------------------+The pointer for the last event executed is defined in the EventLast variable. This is used when events are added.If you require RAM, define a user structure, and cast the event RAM user[] to that structure.Example:typedef struct rob{    FIXED  posX, posY, posZ;    ANGLE  angX, angY, angZ;    PDATA *pat;} ROBOT;   /* This structure cannot exceed 112 bytes */void rob_control(EVENT *evptr){    ROBOT *rbptr;    rbptr = (ROBOT *)evptr->user;    rbptr->posX = to_fixed(0);    rbptr->posY = to_fixed(0);    rbptr->posZ = to_fixed(0);    rbptr->pat = &PD_Robot;}Work can be linked and held with the pointer list. To move multiple characters with one event, use work to allocate RAM.typedef struct road{    struct road *next;    FIXED  posX, posY, posZ;    PDATA *pat;} ROAD;typedef struct rdat{    Sint16 px, py, pz;    Uint16 pn;} ROAD_DAT;ROAD_DAT roadtbl[] = {    {   0,   0,   0, PN_ROAD},    {   0,   0, 100, PN_ROAD},    {   0,   0, 200, PN_ROAD}};void InitRoadControl(EVENT *evptr){    WORK  *wkptr;    ROAD  *rdptr;    ROAD_DAT *rdtptr;    int    cnt;    rdptr = (ROAD *)evptr;    rdtptr = roadtbl;    for(cnt = sizeof(roadtbl) / sizeof(ROAD_DAT); cnt-- > 0;){        if((wkptr = slGetWork()) == NULL){            break;        }        rdptr->next = (ROAD *)wkptr;        /* The first pointer is placed in the work for the event*/        rdptr = (ROAD *)wkptr;        rdptr->posX = rdtptr->px << 16;    /* Position */        rdptr->posY = rdtptr->py << 16;        rdptr->posZ = rdtptr->pz << 16;        rdptr->pat = pattbl[rdptr->pn];    /* Pattern data */        rdtptr++;    }    rdptr->next = NULL;                    /* End mark */    evptr->exad = (void *)RoadControl;}